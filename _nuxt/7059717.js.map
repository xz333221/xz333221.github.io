{"version":3,"sources":["webpack:///./.nuxt/content/query-builder.js","webpack:///./.nuxt/content/plugin.client.lazy.js"],"names":["pick","obj","keys","Object","filter","key","includes","reduce","newObj","assign","omit","QueryBuilder","options","query","path","init","text","postprocess","this","onlyKeys","withoutKeys","unshift","data","map","item","Array","isArray","field","direction","simplesort","desc","find","value","$fts","type","prefix_length","fuzziness","extended","minimum_should_match","should","fullTextSearchFields","operator","slug","before","after","push","fn","index","findIndex","slice","fill","prevSlice","nextSlice","prevIndex","i","nextIndex","n","parseInt","limit","offset","removeMeta","Error","JSON","parse","stringify","module","exports","LokiFullTextSearch","register","db","items","dirs","$content","paths","from","arguments","forEach","argument","join","replace","isDir","dir","deep","$regex","chain","database","Loki","loadJSONObject","getCollection"],"mappings":"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","file":"7059717.js","sourcesContent":["const pick = (obj, keys = []) => {\n  return Object.keys(obj)\n    .filter(key => keys.includes(key))\n    .reduce((newObj, key) => Object.assign(newObj, { [key]: obj[key] }), {})\n}\n\nconst omit = (obj, keys = []) => {\n  return Object.keys(obj)\n    .filter(key => !keys.includes(key))\n    .reduce((newObj, key) => Object.assign(newObj, { [key]: obj[key] }), {})\n}\n\nclass QueryBuilder {\n  constructor ({ query, path, init, text, postprocess = [] }, options) {\n    this.query = query\n    this.path = path\n    this.init = init\n    this.postprocess = postprocess\n    this.options = options || {}\n    this.onlyKeys = null\n    this.withoutKeys = null\n\n    if (!text) {\n      // Remove text field from response\n      this.postprocess.unshift(data => data.map(item => omit(item, ['text'])))\n    }\n  }\n\n  /**\n   * Select a subset of fields\n   * @param {Array} keys - Array of fields to be picked.\n   * @returns {QueryBuilder} Returns current instance to be chained\n   */\n  only (keys) {\n    // Assign keys to this.onlyKeys to be processed in fetch\n    this.onlyKeys = Array.isArray(keys) ? keys : [keys]\n    // Return current instance\n    return this\n  }\n\n  /**\n   * Remove a subset of fields\n   * @param {Array} keys - Array of fields to be picked.\n   * @returns {QueryBuilder} Returns current instance to be chained\n   */\n  without (keys) {\n    // Assign keys to this.withoutKeys to be processed in fetch\n    this.withoutKeys = Array.isArray(keys) ? keys : [keys]\n    // Return current instance\n    return this\n  }\n\n  /**\n   * Sort results\n   * @param {string} field - Field key to sort on.\n   * @param {string} direction - Direction of sort (asc / desc).\n   * @returns {QueryBuilder} Returns current instance to be chained\n   */\n  sortBy (field, direction) {\n    this.query = this.query.simplesort(field, { desc: direction === 'desc' })\n    return this\n  }\n\n  /**\n   * Filter results\n   * @param {object} query - Where query.\n   * @returns {QueryBuilder} Returns current instance to be chained\n   */\n  where (query) {\n    this.query = this.query.find(query)\n    return this\n  }\n\n  /**\n   * Search results\n   * @param {(Object|string)} query - Search query object or field or search value.\n   * @param {string} value - Value of search (means query equals to field).\n   * @returns {QueryBuilder} Returns current instance to be chained\n   */\n  search (query, value) {\n    let $fts\n\n    if (typeof query === 'object') {\n      $fts = query\n    } else if (value) {\n      $fts = {\n        query: {\n          type: 'match',\n          field: query,\n          value,\n          prefix_length: 1,\n          fuzziness: 1,\n          extended: true,\n          minimum_should_match: 1\n        }\n      }\n    } else {\n      $fts = {\n        query: {\n          type: 'bool',\n          should: this.options.fullTextSearchFields.map(field => ({\n            type: 'match',\n            field,\n            value: query,\n            prefix_length: 1,\n            operator: 'and',\n            minimum_should_match: 1,\n            fuzziness: 1,\n            extended: true\n          }))\n        }\n      }\n    }\n\n    this.query = this.query.find({ $fts })\n    return this\n  }\n\n  /**\n   * Surround results\n   * @param {string} slug - Slug of the file to surround.\n   * @param {Object} options - Options to surround (before / after).\n   * @returns {QueryBuilder} Returns current instance to be chained\n   */\n  surround (slug, { before = 1, after = 1 } = {}) {\n    // Add slug to onlyKeys if only method has been called before\n    if (this.onlyKeys) {\n      this.onlyKeys.push('slug')\n    }\n    // Remove slug from withoutKeys if without method has been called before\n    if (this.withoutKeys) {\n      this.withoutKeys = this.withoutKeys.filter(key => key !== 'slug')\n    }\n\n    const fn = (data) => {\n      const index = data.findIndex(item => item.slug === slug)\n      const slice = new Array(before + after).fill(null, 0)\n      if (index === -1) {\n        return slice\n      }\n\n      const prevSlice = data.slice(index - before, index)\n      const nextSlice = data.slice(index + 1, index + 1 + after)\n\n      let prevIndex = 0\n      for (let i = before - 1; i >= 0; i--) {\n        slice[i] = prevSlice[prevIndex] || null\n        prevIndex++\n      }\n\n      let nextIndex = 0\n      for (let i = before; i <= after; i++) {\n        slice[i] = nextSlice[nextIndex] || null\n        nextIndex++\n      }\n\n      return slice\n    }\n\n    this.postprocess.push(fn)\n    return this\n  }\n\n  /**\n   * Limit number of results\n   * @param {number} n - Limit number.\n   * @returns {QueryBuilder} Returns current instance to be chained\n   */\n  limit (n) {\n    if (typeof n === 'string') { n = parseInt(n) }\n\n    this.query = this.query.limit(n)\n    return this\n  }\n\n  /**\n   * Skip number of results\n   * @param {number} n - Skip number.\n   * @returns {QueryBuilder} Returns current instance to be chained\n   */\n  skip (n) {\n    if (typeof n === 'string') { n = parseInt(n) }\n\n    this.query = this.query.offset(n)\n    return this\n  }\n\n  /**\n   * Collect data and apply process filters\n   * @returns {(Object|Array)} Returns processed data\n   */\n  // eslint-disable-next-line require-await\n  async fetch () {\n    // Collect data without meta fields\n    let data = this.query.data({ removeMeta: true })\n    // Handle only keys\n    if (this.onlyKeys) {\n      // Map data and returns object picked by keys\n      const fn = data => data.map(item => pick(item, this.onlyKeys))\n      // Apply pick during postprocess\n      this.postprocess.unshift(fn)\n    }\n    // Handle without keys\n    if (this.withoutKeys) {\n      // Map data and returns object picked by keys\n      const fn = data => data.map(item => omit(item, this.withoutKeys))\n      // Apply pick during postprocess\n      this.postprocess.unshift(fn)\n    }\n    // Apply postprocess fns to data\n    for (const fn of this.postprocess) {\n      data = fn(data)\n    }\n\n    if (!data) {\n      throw new Error(`${this.path} not found`)\n    }\n\n    return JSON.parse(JSON.stringify(data))\n  }\n}\n\nmodule.exports = QueryBuilder\n","import QueryBuilder from './query-builder'\nimport Loki from '@lokidb/loki'\nimport LokiFullTextSearch from '@lokidb/full-text-search'\n\nLokiFullTextSearch.register()\n\nconst dirs = [\"/\"]\n  let db, items\n\nconst $content = function () {\n  let options = {}\n  const paths = []\n  Array.from(arguments).forEach((argument) => {\n    if (typeof argument === 'string') {\n      paths.push(argument)\n    } else if (typeof argument === 'object') {\n      options = argument\n    }\n  })\n\n  const path = `/${paths.join('/').replace(/\\/+/g, '/')}`\n  const isDir = !path || !!dirs.find(dir => dir === path)\n  // Look for dir or path\n  const query = isDir ? { dir: options.deep ? { $regex: path } : path } : { path }\n  // Postprocess to get only first result (findOne)\n  const postprocess = isDir ? [] : [data => data[0]]\n\n  return new QueryBuilder({\n    query: items.chain().find(query, !isDir),\n    postprocess\n  }, {\n    fullTextSearchFields: [\"title\",\"description\",\"slug\",\"text\"]\n  })\n}\n\nexport default (database) => {\n  db = new Loki('content.db')\n  db.loadJSONObject(database)\n  items = db.getCollection('items')\n\n  return $content\n}\n"],"sourceRoot":""}